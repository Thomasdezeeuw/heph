// Copyright 2017 Thomas de Zeeuw
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license <LICENSE-MIT
// or http://opensource.org/licenses/MIT>, at your option. This file may not be
// used, copied, modified, or distributed except according to those terms.

use std::marker::PhantomData;

use super::actor::{Actor, NewActor};

/// The supervisor trait the determines how to handle error generated by actors.
pub trait Supervisor {
    /// The type of error this supervisor can handle, returned by the actor.
    type Error;

    /// The actor that generates the error.
    type Actor: Actor<Error = Self::Error>;

    /// The NewActor trait that can be used to reuse the actor. The type is a
    /// little complicated but it just copies the types from the `Actor` trait
    /// above and the `Error` type.
    type NewActor: NewActor<Actor = Self::Actor>;

    /// Handle an error the actor generated. It will receive a reference to
    /// [`NewActor`] to call reuse on, the actor that generated the error and
    /// the error itself.
    ///
    /// [`NewActor`]: ../actor/trait.NewActor.html
    fn handle_error(&self,
        new_actor: &Self::NewActor,
        actor: &mut Self::Actor,
        error: Self::Error,
    );
}

/// This supervisor simply restarts the actor and ignores the error, thus the
/// error should be logged by the actor.
pub struct RestartSupervisor<A, N>(PhantomData<(A, N)>);

impl<A, N> Default for RestartSupervisor<A, N> {
    fn default() -> RestartSupervisor<A, N> {
        RestartSupervisor(PhantomData)
    }
}

impl<A, N> Supervisor for RestartSupervisor<A, N>
    where A: Actor,
          N: NewActor<Actor = A>,
{
    type Error = A::Error;
    type Actor = A;
    type NewActor = N;
    fn handle_error(&self, new_actor: &N, actor: &mut A, _: Self::Error) {
        actor.pre_restart();
        new_actor.reuse(actor);
        actor.post_restart();
    }
}
