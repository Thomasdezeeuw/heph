//! Module with the [`Supervisor`] trait definition.
//!
//! A `Supervisor` supervises one or more actors, hence the name. It is
//! responsible for determining what to do next if an [`Actor`] encountered an
//! error. Currently there are two [strategies] to deal with errors; restart the
//! actor to deal with the remaining messages, or stop the actor and drop the
//! remaining messages.
//!
//! Two simple supervisor implementations are provided:
//!
//! - [`LogSupervisor`]: logs the error, and
//! - [`NopSupervisor`]: does nothing.
//!
//! However both implementations are often too simple for actual use, and are
//! mostly here as example implementations.
//!
//! [`Supervisor`]: trait.Supervisor.html
//! [`Actor`]: ../actor/trait.Actor.html
//! [strategies]: enum.RestartStrategy.html
//! [`LogSupervisor`]: struct.LogSupervisor.html
//! [`NopSupervisor`]: struct.NopSupervisor.html

use std::fmt::Display;

use actor::Actor;

/// The strategy the actor system needs to take regarding a faulty actor.
///
/// See [`Supervisor.handle_error`].
///
/// [`Supervisor.handle_error`]: trait.Supervisor.html#tymethod.handle_error
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
#[non_exhaustive]
pub enum RestartStrategy {
    /// Restart the actor.
    ///
    /// This will cause the actor to be restarted. It will drop the message
    /// currently being processed. Messages not yet handled by the actor, the
    /// ones waiting in the mailbox, will be handled by the new actor.
    Restart,
    /// Stop the actor.
    ///
    /// This will cause the actor to be stopped, without another one being
    /// started in its place. Note that when choosing this strategy it will
    /// cause message delivery failures in other actors that depend on this
    /// actor.
    Stop,
}

/// The supervisor trait supervises one or more [`Actor`]s.
///
/// The main task of the supervisor is to determine how to handle error
/// generated by actors.
///
/// Two simple supervisor implementations are provided: [`LogSupervisor`] and
/// [`NopSupervisor`].
///
/// [`Actor`]: ../actor/trait.Actor.html
/// [`LogSupervisor`]: struct.LogSupervisor.html
/// [`NopSupervisor`]: struct.NopSupervisor.html
pub trait Supervisor<E, A> {
    /// Handle an error generated by an [`Actor`]. It will receive a reference to the
    /// actor that caused the error and the error itself.
    ///
    /// [`Actor`]: ../actor/trait.Actor.html
    fn handle_error(&mut self, actor: &mut A, error: E) -> RestartStrategy
        where A: Actor<Error = E>;
}

/// A supervisor that logs the error generated by an actor.
///
/// # Example
///
/// ```
/// # extern crate actor;
/// # extern crate futures_core;
/// # use std::{fmt, io};
/// # use actor::actor::Actor;
/// # use actor::supervisor::Supervisor;
/// # use futures_core::{Future, Poll};
/// # use futures_core::task::Context;
/// use actor::supervisor::{LogSupervisor, RestartStrategy};
///
/// // Our actor that implements the `Actor` trait.
/// struct MyActor;
///
/// # impl Future for MyActor {
/// #     type Item = ();
/// #     type Error = ();
/// #     fn poll(&mut self, _: &mut Context) -> Poll<(), ()> { unimplemented!(); }
/// # }
/// #
/// # impl Actor for MyActor {
/// #     type Message = String;
/// #     fn handle(&mut self, _: &mut Context, _: String) -> Poll<(), ()> { unimplemented!(); }
/// # }
/// #
/// # impl fmt::Display for MyActor {
/// #    fn fmt(&self, _: &mut fmt::Formatter) -> fmt::Result { Ok(()) }
/// # }
/// #
/// # fn main() {
/// // Our `Supervisor` implementation that logs errors and restarts the actors.
/// let supervisor = LogSupervisor(RestartStrategy::Restart);
/// #
/// # fn use_supervisor<S: Supervisor<String, MyActor>>(supervisor: S) { }
/// # use_supervisor(supervisor);
/// # }
/// ```
#[derive(Debug)]
pub struct LogSupervisor(pub RestartStrategy);

impl<E, A> Supervisor<E, A> for LogSupervisor
    where E: Display,
          A: Display,
{
    fn handle_error(&mut self, actor: &mut A, error: E) -> RestartStrategy
        where A: Actor<Error = E>
    {
        error!("actor {} caused error: {}", actor, error);
        self.0
    }
}

/// A supervisor that ignores the error generated by the actor and does nothing.
///
/// A poor supervisor if you ask me...
///
/// # Example
///
/// ```
/// # extern crate actor;
/// # extern crate futures_core;
/// # use std::{fmt, io};
/// # use actor::actor::Actor;
/// # use actor::supervisor::Supervisor;
/// # use futures_core::{Future, Poll};
/// # use futures_core::task::Context;
/// use actor::supervisor::{NopSupervisor, RestartStrategy};
///
/// // Our actor that implements the `Actor` trait.
/// struct MyActor;
///
/// # impl Future for MyActor {
/// #     type Item = ();
/// #     type Error = ();
/// #     fn poll(&mut self, _: &mut Context) -> Poll<(), ()> { unimplemented!(); }
/// # }
/// #
/// # impl Actor for MyActor {
/// #     type Message = ();
/// #     fn handle(&mut self, _: &mut Context, _: ()) -> Poll<(), ()> { unimplemented!(); }
/// # }
/// #
/// # impl fmt::Display for MyActor {
/// #    fn fmt(&self, _: &mut fmt::Formatter) -> fmt::Result { Ok(()) }
/// # }
/// #
/// # fn main() {
/// // Our `Supervisor` implementation that does nothing and tells the actor
/// // system to stop the actor and not restart it.
/// let supervisor = NopSupervisor(RestartStrategy::Stop);
/// #
/// # fn use_supervisor<S: Supervisor<(), MyActor>>(supervisor: S) { }
/// # use_supervisor(supervisor);
/// # }
/// ```
#[derive(Debug)]
pub struct NopSupervisor(pub RestartStrategy);

impl<E, A> Supervisor<E, A> for NopSupervisor {
    fn handle_error(&mut self, _: &mut A, _: E) -> RestartStrategy
        where A: Actor<Error = E>
    {
        self.0
    }
}
