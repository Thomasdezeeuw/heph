//! Module with the `Supervisor` trait definition.
//!
//! A [`Supervisor`] supervises one or more actors, hence the name. It is
//! responsible for determining what to do next if an [`Actor`] encountered an
//! error. Currently there are two [strategies] to deal with errors; restart the
//! actor to deal with the remaining messages, or stop the actor and drop the
//! remaining messages.
//!
//! A simple supervisor implementation is provided that just logs the errors;
//! the [`LogSupervisor`].
//!
//! [`Supervisor`]: trait.Supervisor.html
//! [`Actor`]: ../actor/trait.Actor.html
//! [strategies]: enum.RestartStrategy.html
//! [`LogSupervisor`]: struct.LogSupervisor.html

use std::fmt::Display;

use crate::actor::Actor;

/// The supervisor trait supervises one or more [`Actor`]s.
///
/// The main task of the supervisor is to determine how to handle error
/// generated by actors.
///
/// A simple supervisor implementation is provided: [`LogSupervisor`].
///
/// [`Actor`]: ../actor/trait.Actor.html
/// [`LogSupervisor`]: struct.LogSupervisor.html
pub trait Supervisor<A>
    where A: Actor,
{
    /// Handle an error generated by an [`Actor`]. It will receive a reference to the
    /// actor that caused the error and the error itself.
    ///
    /// [`Actor`]: ../actor/trait.Actor.html
    fn handle_error(&mut self, actor: &mut A, error: A::Error) -> RestartStrategy;
}

/// The strategy the actor system needs to take regarding a faulty actor.
///
/// See [`Supervisor.handle_error`].
///
/// [`Supervisor.handle_error`]: trait.Supervisor.html#tymethod.handle_error
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
#[non_exhaustive]
pub enum RestartStrategy {
    /// Restart the actor.
    ///
    /// This will cause the actor to be restarted. It will drop the message
    /// currently being processed. Messages not yet handled by the actor, the
    /// ones waiting in the mailbox, will be handled by the new actor.
    Restart,

    /// Stop the actor.
    ///
    /// This will cause the actor to be stopped, without another one being
    /// started in its place. Note that when choosing this strategy it will
    /// cause message delivery failures in other actors that depend on this
    /// actor.
    Stop,
}

/// A supervisor that logs the error generated by an actor.
///
/// # Example
///
/// ```
/// # extern crate actor;
/// # use std::{fmt, io};
/// # use actor::actor::{Actor, ActorContext, ActorResult};
/// # use actor::supervisor::Supervisor;
/// use actor::supervisor::{LogSupervisor, RestartStrategy};
///
/// // Our actor that implements the `Actor` trait.
/// struct MyActor;
///
/// # impl Actor for MyActor {
/// #     type Message = ();
/// #     type Error = String;
/// #     fn handle(&mut self, ctx: &mut ActorContext, msg: Self::Message) -> ActorResult<Self::Error> {
/// #         unimplemented!();
/// #     }
/// #     fn poll(&mut self, _: &mut ActorContext) -> ActorResult<Self::Error> {
/// #         unimplemented!();
/// #     }
/// # }
/// #
/// # impl fmt::Display for MyActor {
/// #    fn fmt(&self, _: &mut fmt::Formatter) -> fmt::Result { Ok(()) }
/// # }
/// #
/// # fn main() {
/// // Our `Supervisor` implementation that logs errors and restarts the actors.
/// let supervisor = LogSupervisor(RestartStrategy::Restart);
/// #
/// # fn use_supervisor<S: Supervisor<MyActor>>(supervisor: S) { }
/// # use_supervisor(supervisor);
/// # }
/// ```
#[derive(Debug)]
pub struct LogSupervisor(pub RestartStrategy);

impl<A> Supervisor<A> for LogSupervisor
    where A: Actor + Display,
          A::Error: Display,
{
    fn handle_error(&mut self, actor: &mut A, error: A::Error) -> RestartStrategy {
        error!("actor {} caused error: {}", actor, error);
        self.0
    }
}
