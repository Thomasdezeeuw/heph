% TODO: add more properties to check.

% A value or nothing.
sort Value = struct T | None;

% A value is send.
act sendSendValue, recvSendValue, sendValue;
% Sender is dropped.
act	sendDropSender, recvDropSender, dropSender;
% Sender is reset.
act	sendResetSender, recvResetSender, resetSender;

% Methods on Receiver.
act try_recv, return_value, return_no_value_err, return_disconnected_err;
act try_peek, return_value_clone; % Uses same errors as `try_recv` above.
act try_reset, return_sender, return_sender_alive_err;


init allow({
		sendValue, dropSender, resetSender,
		try_recv, return_value, return_no_value_err, return_disconnected_err,
		try_peek, return_value_clone,
		try_reset, return_sender, return_sender_alive_err
	}, comm({
			sendSendValue | recvSendValue -> sendValue,
			sendDropSender | recvDropSender -> dropSender,
			sendResetSender | recvResetSender -> resetSender
		},
		new_channel
	)
);


% Create a new one-shot channel.
proc new_channel = Sender || Receiver(true, None);


% The `Sender`.
proc Sender = send_value + drop_sender;
% Send a value (and drop itself).
proc send_value = sendSendValue . drop_sender;
% Drop the sender, then wait until its reset and restart the Sender.
proc drop_sender = sendDropSender . recvResetSender . Sender;


% The `Receiver`.
proc Receiver(sender_alive: Bool, value: Value) =
	(recvSendValue . Receiver(sender_alive, T)) +
	(recvDropSender . Receiver(false, value)) +
	try_receive_value(sender_alive, value) +
	try_peek_value(sender_alive, value) +
	try_reset_channel(sender_alive, value);
% `Sender.try_recv`.
proc try_receive_value(sender_alive: Bool, value: Value) =
	try_recv . (sender_alive == true) -> (
		% Sender alive, thus hasn't send a value yet (following the code).
		return_no_value_err . Receiver(sender_alive, value)
	) <> (value == None) -> (
		% No value and the sender is disconnected.
		return_disconnected_err . Receiver(sender_alive, value)
	) <> (
		% Value was send, return it to the user and reset the channel.
		return_value . sendResetSender . Receiver(true, None)
	);
% `Sender.try_peek`.
proc try_peek_value(sender_alive: Bool, value: Value) =
	try_peek . (sender_alive == true) -> (
		% Sender alive, thus hasn't send a value yet (following the code).
		return_no_value_err . Receiver(sender_alive, value)
	) <> (value == None) -> (
		% No value and the sender is disconnected.
		return_disconnected_err . Receiver(sender_alive, value)
	) <> (
		% Value was send, clone and return it.
		return_value_clone . Receiver(sender_alive, value)
	);
% `Sender.try_reset`.
proc try_reset_channel(sender_alive: Bool, value: Value) =
	try_reset . (sender_alive == true) -> (
		% Sender alive, thus can't reset the channel.
		return_sender_alive_err . Receiver(sender_alive, value)
	) <> (
		% Sender is dropped, so we can reset the channel.
		return_sender . sendResetSender . Receiver(true, None)
	);
